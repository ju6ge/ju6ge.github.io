<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Felix Richter Website</title>
  <link href="https://www.felixrichter.tech/feed.xml" rel="self"/>
  <link href="https://www.felixrichter.tech/"/>
  <updated>2023-04-20T00:00:00+00:00</updated>
  <id>https://www.felixrichter.tech/</id>
  <generator>Hugo -- gohugo.io</generator>
  <entry>
    <title type="html"><![CDATA[Improving Desk Device Utilization with Networking]]></title>
    <link href="https://www.felixrichter.tech/posts/improvingyourdeskwithnetworking/"/>
    <id>https://www.felixrichter.tech/posts/improvingyourdeskwithnetworking/</id>
    <author>
      <name>Felix Richter</name>
    </author>
	<published>2023-04-20T00:00:00+00:00</published>
	<updated>2023-04-20T00:00:00+00:00</updated>
	<content type="html"><![CDATA[<p>In the past month I have renovated my appartment. Because of this I had to redo my entire desk setup. If you know me that means spending a lot time managing cables 😅.
But I am really happy with the result. See for yourself …</p>
<figure><img src="/desksetup/desk.jpg" width="1000"/>
</figure>

<p>I always wanted to be flexible in how I use the devices on my desk. I want to switch between using my laptop and desktop without having to replug everything.
But I also want to be able to use certain devices from both at the same time. I have been using USB Hubs and the like. But I always was left wanting.
To be fair my current solution is still not as perfect as in my dreams, but it is damn close.</p>
<p>So lets begin with the easy things. The monitors have multiple inputs, so I just connect those to my desktop and the docking station and voila. Well switching still requires me
to use the monitor menus, but that I don&rsquo;t really need to do that because I set them to &ldquo;automatic mode&rdquo; meaning the just show which ever device starts sending data first. And I don&rsquo;t really
need to use all monitors with the laptop when my desktop is running anyway so switching does not happen much.</p>
<p>For the keyboard and mouse I am using the &ldquo;Logitech MX&rdquo; keyboard and &ldquo;Logitech MX Master&rdquo; mouse. The can be paired with multiple Logitech wireless receivers. The devices can the be switch with
the press of a button. Sadly switching one does not switch the other automatically which is still a little annyoing but I have seen some scripts that could be used to automate that as well.
Maybe I  will give that a shot. I still have a &ldquo;USB Switch&rdquo; which is connected to the desktop and laptop, it has a switch to toggle which device is &ldquo;connected&rdquo;. I mostly use it for my yubikey
now. It also was fine for switching my previous mouse and keyboard.</p>
<p>There is still some room for improvements here, but that is not what has been bugging me. The parts I really wanted to be better are the Speakers, Microphone and the Webcam. In an ideal world
they should be accessible on either device or both at the same time. Hence the USB Switch is not a good solution since that only enables operation with a single device at a time. Also using the
USB switch is annyoing for other reasons. It means the audio dac is reset when switching devices resulting in an unpleasent noise coming out of my speakers. And also having all devices
connected to a switch takes away the ability to attach usb sticks or other devices that i really only need temporarily and daisy chaning usb hubs often results in inconsistent behavior.</p>
<h4 id="what-would-be-a-better-solution">What would be a better solution?</h4>
<p>Enter everybodies favorite single board computer the Raspberry Pi 🥧. Luckly I still have one lying around since getting one online is next to impossible if you don&rsquo;t want to pay a scalper
an unreasonable amount of money. Hopefully this will change. But anyway how can it help me acomplish my goal.</p>
<p>Thanks to a little something called networking computers can talk to each other. So it should be possible to attach the audio dac and webcam to the pi and then stream the video and audio data
to both the laptop and desktop. What do we need to accomplish that.</p>
<ol>
<li>Configure the Network</li>
<li>Setup Pipewire to run as system service</li>
<li>Enable audio streaming with the pipewire pulse server implementation</li>
<li>Enable laptop and desktop to discover audio devices</li>
<li>Setup USBIP for sharing the webcam</li>
</ol>
<h4 id="network-setup">Network Setup</h4>
<p>I do not want to share the devices with my entire home network, I just want to share with devices attached to the desk. Since the raspberry only has one network jack and using wireless for
streaming data is not a great idea because of increased latency, the first thing I did was setup VLAN that is only availible to the devices on my desk.</p>
<figure><img src="/desksetup/desk_network.jpg" width="600"/>
</figure>

<p>First of the network switch needs to support VLANs, there are a lot of switches capable of doing this. They are a little more expensive then unmanged switches, but a basic models are
availible starting at around 30€. I opted for a more expensive model from microtik (CSS610-8G-2S+) that is also able to support fibre glas connections instead of just RJ45. Then
I configured the switch to setup the home network on each port in untagged mode. Then I created a VLAN with ID 2668 which will only be availible on the ports attached to the raspberry pi,
desktop and laptop in tagged mode. The choise of the ID is arbirary, just make sure to not have clashes with other VLAN if you already have a more elaborate network setup at home.</p>
<p>Next the devices need to be configured to know about the VLAN and the IP address range needs to be configured. I like to use <code>systemd-networkd</code> for this. The configuration
is done with three files in the <code>/etc/systemd/network</code> directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@pi ~<span style="color:#f92672">]</span><span style="color:#75715e"># tree /etc/systemd/network</span>
</span></span><span style="display:flex;"><span>/etc/systemd/network
</span></span><span style="display:flex;"><span>|-- 0-audio.netdev
</span></span><span style="display:flex;"><span>|-- 1-audio.network
</span></span><span style="display:flex;"><span><span style="color:#e6db74">`</span>-- eth.network
</span></span></code></pre></div><p>The file <code>0-audio.netdev</code> defines the VLAN:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#66d9ef">[NetDev]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Name</span><span style="color:#f92672">=</span><span style="color:#e6db74">audio</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Kind</span><span style="color:#f92672">=</span><span style="color:#e6db74">vlan</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[VLAN]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Id</span><span style="color:#f92672">=</span><span style="color:#e6db74">2668</span>
</span></span></code></pre></div><p>The file <code>eth.network</code> configures the normal home network on the pi, here we need to add a line specifing that the VLAN is availible on this port:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#66d9ef">[Match]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Name</span><span style="color:#f92672">=</span><span style="color:#e6db74">eth*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Network]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DHCP</span><span style="color:#f92672">=</span><span style="color:#e6db74">yes</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">IPv6PrivacyExtensinos</span><span style="color:#f92672">=</span><span style="color:#e6db74">true</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">VLAN</span><span style="color:#f92672">=</span><span style="color:#e6db74">audio</span>
</span></span></code></pre></div><p>Lastly the VLAN network needs to be configured. Since the pi is running continously it is useful to configure its ip statically and setup a DHCP server.
All of this is configured with just a few lines in the <code>1-audio.network</code> file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#66d9ef">[Match]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Name</span><span style="color:#f92672">=</span><span style="color:#e6db74">audio</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Network]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Address</span><span style="color:#f92672">=</span><span style="color:#e6db74">172.16.128.1/24</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DHCPServer</span><span style="color:#f92672">=</span><span style="color:#e6db74">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[DHCPServer]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PoolOffset</span><span style="color:#f92672">=</span><span style="color:#e6db74">100</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PoolSize</span><span style="color:#f92672">=</span><span style="color:#e6db74">100</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EmitRouter</span><span style="color:#f92672">=</span><span style="color:#e6db74">false</span>
</span></span></code></pre></div><p>The same steps are used to configure the VLAN on the desktop and laptop, the only things that change are the interface names for the home network and that the audio vlans network can use the configured DHCP server to obtain a lease. Resulting in the follwing <code>1-audio.network</code> file on the clients.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#66d9ef">[Match]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Name</span><span style="color:#f92672">=</span><span style="color:#e6db74">audio</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Network]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DHCP</span><span style="color:#f92672">=</span><span style="color:#e6db74">yes</span>
</span></span></code></pre></div><p>Of course to use systemd-networkd the service needs to be enabled: <code>systemctl enable --now systemd-networkd</code>.</p>
<h4 id="pipewire-system-service">Pipewire System Service</h4>
<p>Pipewire intends to be a modern linux media deamon. It is still in active development. For now it already can be used as a replacement for pulseaudio or jack.
Normally pipewire starts when you login to your user session. But since there is no desktop running on the pi pipewire needs to be configured to run as a system
service.</p>
<p>First of the software packages need to be installed. I am more of a minimalist when it comes to the systems I configure, means I am running archlinux on the raspberry
pi. The packages names might vary if you are running raspbian. For me doning</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>pacman -S pipewire pipewire-alsa pipewire-jack pipewire-pulse pipewire-zeroconf wireplumber pipewire-docs pipewire-audio realtime
</span></span></code></pre></div><p>installed all desired packages. There is not a lot of documentation on how to setup pipewire as a system service. I found
<a href="https://gitlab.freedesktop.org/pipewire/pipewire/-/issues/2196">this issue thread</a> which lists all the steps required.
Maybe the process will get simpler in the future, but for now a lot of steps are required.</p>
<p>First a pipewire user and group needs to be created with a statically assigned uid and gid. This is important to correctly set the environment variables in the service
files created later. The pipewire user needs to be added to the audio and realtime group.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>addgroup --gid <span style="color:#ae81ff">901</span> pipewire 
</span></span><span style="display:flex;"><span>adduser --system  --uid <span style="color:#ae81ff">091</span> --gid <span style="color:#ae81ff">901</span> pipewire
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> g in audio realtime; <span style="color:#66d9ef">do</span> sudo adduser pipewire <span style="color:#e6db74">${</span>g<span style="color:#e6db74">}</span>; <span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>Next we need to add a configuration file <code>/etc/security/limits.d/99-realtime-privileges.conf</code> to allow the realtime group to change the process priorities to the levels recommended
by pipewire.</p>
<pre tabindex="0"><code>@realtime - rtprio 98
@realtime - memlock unlimited
@realtime - nice -11
</code></pre><p>With the limits in place, the next step is to setup systemd units for <code>pipewire</code>, <code>pipewire-pulse</code> and <code>wireplumber</code>. In total 5 files need to be created:</p>
<ul>
<li><code>/etc/systemd/system/pipewire.socket</code></li>
<li><code>/etc/systemd/system/pipewire.service</code></li>
<li><code>/etc/systemd/system/pipewire-pulse.socket</code></li>
<li><code>/etc/systemd/system/pipewire-pulse.service</code></li>
<li><code>/etc/systemd/system/wireplumber.service</code></li>
</ul>
<p>The content of these files is as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#75715e">#/etc/systemd/system/pipewire.socket</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Unit]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Description</span><span style="color:#f92672">=</span><span style="color:#e6db74">PipeWire Multimedia System Socket</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Socket]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Priority</span><span style="color:#f92672">=</span><span style="color:#e6db74">6</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ListenStream</span><span style="color:#f92672">=</span><span style="color:#e6db74">%t/pipewire/pipewire-0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SocketUser</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SocketGroup</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SocketMode</span><span style="color:#f92672">=</span><span style="color:#e6db74">0660</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Install]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">WantedBy</span><span style="color:#f92672">=</span><span style="color:#e6db74">sockets.target</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#75715e">#/etc/systemd/system/pipewire.service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Unit]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Description</span><span style="color:#f92672">=</span><span style="color:#e6db74">PipeWire Multimedia Service</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Before</span><span style="color:#f92672">=</span><span style="color:#e6db74">gdm.service</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># We require pipewire.socket to be active before starting the daemon, because</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># while it is possible to use the service without the socket, it is not clear</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># why it would be desirable.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Installing pipewire and doing `systemctl start pipewire` will not get the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># socket started, which might be confusing and problematic if the server is to</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># be restarted later on, as the client autospawn feature might kick in. Also, a</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># start of the socket unit will fail, adding to the confusion.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># After=pipewire.socket is not needed, as it is already implicit in the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># socket-service relationship, see systemd.socket(5).</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Requires</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire.socket</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Service]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">User</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Type</span><span style="color:#f92672">=</span><span style="color:#e6db74">simple</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ExecStart</span><span style="color:#f92672">=</span><span style="color:#e6db74">/usr/bin/pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Restart</span><span style="color:#f92672">=</span><span style="color:#e6db74">on-failure</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">RuntimeDirectory</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">RuntimeDirectoryPreserve</span><span style="color:#f92672">=</span><span style="color:#e6db74">yes</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">PIPEWIRE_RUNTIME_DIR=%t/pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add if you need debugging</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Environment=PIPEWIRE_DEBUG=4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># These hardcoded runtime and dbus paths must stay this way for a system service</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># as the User= is not resolved here 8(</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## NOTE we do not change PIPEWIRE_RUNTIME_DIR as this is the system socket dir...</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Environment=PIPEWIRE_RUNTIME_DIR=/run/user/91/pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">XDG_RUNTIME_DIR=/run/user/91</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/91/bus</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#75715e">#/etc/systemd/system/pipewire-pulse.socket</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Unit]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Description</span><span style="color:#f92672">=</span><span style="color:#e6db74">PipeWire PulseAudio</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Conflicts</span><span style="color:#f92672">=</span><span style="color:#e6db74">pulseaudio.socket</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Socket]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Priority</span><span style="color:#f92672">=</span><span style="color:#e6db74">6</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ListenStream</span><span style="color:#f92672">=</span><span style="color:#e6db74">%t/pulse/native</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SocketUser</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SocketGroup</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SocketMode</span><span style="color:#f92672">=</span><span style="color:#e6db74">0660</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Install]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">WantedBy</span><span style="color:#f92672">=</span><span style="color:#e6db74">sockets.target</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#75715e">#/etc/systemd/system/pipewire-pulse.service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Unit]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Description</span><span style="color:#f92672">=</span><span style="color:#e6db74">PipeWire PulseAudio</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># We require pipewire-pulse.socket to be active before starting the daemon, because</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># while it is possible to use the service without the socket, it is not clear</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># why it would be desirable.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A user installing pipewire and doing `systemctl --user start pipewire-pulse`</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># will not get the socket started, which might be confusing and problematic if</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the server is to be restarted later on, as the client autospawn feature</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># might kick in. Also, a start of the socket unit will fail, adding to the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># confusion.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># After=pipewire-pulse.socket is not needed, as it is already implicit in the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># socket-service relationship, see systemd.socket(5).</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Requires</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire-pulse.socket</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Wants</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire.service pipewire-session-manager.service</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">After</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire.service pipewire-session-manager.service</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Conflicts</span><span style="color:#f92672">=</span><span style="color:#e6db74">pulseaudio.service</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To ensure that multiple user instances are not created. May not be requiered</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Before</span><span style="color:#f92672">=</span><span style="color:#e6db74">gdm.service</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Service]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">User</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Type</span><span style="color:#f92672">=</span><span style="color:#e6db74">simple</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ExecStart</span><span style="color:#f92672">=</span><span style="color:#e6db74">/usr/bin/pipewire-pulse</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Restart</span><span style="color:#f92672">=</span><span style="color:#e6db74">on-failure</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Slice</span><span style="color:#f92672">=</span><span style="color:#e6db74">session.slice</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># These hardcoded runtime and dbus paths must stay this way for a system service</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># as the User= is not resolved here 8(</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">PULSE_RUNTIME_PATH=/home/pipewire</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/91/bus</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Install]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Also</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire-pulse.socket</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">WantedBy</span><span style="color:#f92672">=</span><span style="color:#e6db74">multi-user.target</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-systemd" data-lang="systemd"><span style="display:flex;"><span><span style="color:#75715e">#/etc/systemd/system/wireplumber.service   </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Unit]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Description</span><span style="color:#f92672">=</span><span style="color:#e6db74">Multimedia Service Session Manager</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">After</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire.service</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">BindsTo</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire.service</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Conflicts</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire-media-session.service</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Service]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">User</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Type</span><span style="color:#f92672">=</span><span style="color:#e6db74">simple</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ExecStart</span><span style="color:#f92672">=</span><span style="color:#e6db74">/usr/bin/wireplumber</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Restart</span><span style="color:#f92672">=</span><span style="color:#e6db74">on-failure</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Slice</span><span style="color:#f92672">=</span><span style="color:#e6db74">session.slice</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># These hardcoded runtime and dbus paths must stay this way for a system service</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># as the User= is not resolved here 8(</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">XDG_RUNTIME_DIR=/run/user/91</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/91/bus</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Install]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">WantedBy</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire.service</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Alias</span><span style="color:#f92672">=</span><span style="color:#e6db74">pipewire-session-manager.service</span>
</span></span></code></pre></div><p>For the services to work correctly we need a running user session with dbus. This can be acomplished by telling <code>loginctl</code> to start a pipewire user session at system boot:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>loginctl enable-linger pipewire 
</span></span></code></pre></div><p>Since running pipewire on the pi as a user is undesired the user services need to be masked.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>systemctl --user --global mask pipewire.socket pipewire.service pipewire-pulse.socket pipewire-pulse.service wireplumber.service
</span></span></code></pre></div><p>After this the pipewire system services we just created can be enabled:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>systemctl enable --now pipewire.socket pipewire.service pipewire-pulse.socket pipewire-pulse.service wireplumber.service
</span></span></code></pre></div><h4 id="configure-pipewire-for-network-streaming">Configure Pipewire for Network Streaming</h4>
<p>At this point piperwire is running on the raspberry after boot up. The next step is to setup network streaming. Thankfully that is easly done in two steps:</p>
<ol>
<li>Setup Pipewire on the Raspberry Pi to be reachable via the VLAN and enable publishing of its devices via zeroconf</li>
<li>Setup clients (laptop, desktop) to listen for zeroconf announcements</li>
</ol>
<p>For compatibility with the existing playback methods and to be a &ldquo;drop-in&rdquo; replacement pipewire has implementated a full pulseaudio server on top of itself.
This way existing tools for managing audio playback and recording can still be used like pavucontrol. Pulseaudio supported being used over a network. This is not low latency
so doing this over wifi is not really recommended, but over a wired connection the latencies are so low that it is not noticable. Pipewire supports this as well.
So all we need to do to create a configuration file to configure network access:</p>
<pre tabindex="0"><code># /etc/pipewire/pipewire-pulse.conf.d/network.conf 
pulse.properties = {
    # the addresses this server listens on
    pulse.min.frag = 32/48000           #0.5ms
    pulse.default.frag = 256/48000       #5ms 
    pulse.min.quantum = 32/48000        #0.5ms
    server.address = [
        &#34;unix:native&#34;
        #&#34;unix:/tmp/something&#34;              # absolute paths may be used
        #&#34;tcp:4713&#34;                         # IPv4 and IPv6 on all addresses
        #&#34;tcp:[::]:9999&#34;                    # IPv6 on all addresses
        #&#34;tcp:127.0.0.1:8888&#34;               # IPv4 on a single address
        #
        { address = &#34;tcp:172.16.128.1:4713&#34;             # address
          max-clients = 64                 # maximum number of clients
          listen-backlog = 32              # backlog in the server listen queue
          client.access = &#34;allowed&#34;     # permissions for clients
        }
    ]
}
</code></pre><p>Per default piperwire-pulse only enables the &ldquo;unix:native&rdquo; socket for access via dbus. To enable the network streaming the last 4 lines starting with address are of interest.
In order to restict access to the VLAN the Ip address of the raspberry pi in the audio network needs to be specified. Also the client.access value needs to be set to &ldquo;allowed&rdquo; in order to enable
all devices on that network to use it.</p>
<p>I also had to decrease the default values for <code>pulse.min.frag</code>, <code>pulse.default.frag</code> and <code>pulse.min.quantum</code> quite a bit in order for the latency of the mircophone to be usable while in a video
call. Otherwise video and audio would be very out of sink. The pipewire documentation warns that this will increase CPU usage. I have not noticed a big impact on the raspberry pi 4 I am using to
do this.</p>
<p>Next enabling the publishing of the pipewire server via zeroconf needs to be enabled. This could be done in the same configuration file. But for better overview over the configuration a created
an extra configuration file:</p>
<pre tabindex="0"><code># /etc/pipewire/pipewire-pulse.conf.d/publish.conf 
context.exec = [
  { path = &#34;pactl&#34;        args = &#34;load-module module-zeroconf-publish&#34; }
]
</code></pre><p>Thats really short. All we are doing is to tell the pulseaudio server to enable the zeroconf publish module. And on the clients we need to enable zeroconf discovery like this:</p>
<pre tabindex="0"><code># /etc/pipewire/pipewire-pulse.conf.d/zeroconf-discover.conf 
context.exec = [
  { path = &#34;pactl&#34;        args = &#34;load-module module-zeroconf-discover&#34; }
]
</code></pre><p>For this to work the zeroconf deamon needs to be running. On linux the zeroconf implementation is provided by <code>avahi</code>. Most systems probably have it running already.
On archlinux enable the <code>avaih-daemon</code> via systemd. The daemon also needs to be running on the raspberry pi for the publishing to work.</p>
<p>If everything worked correctly you should see the audio devices attached to the pi pop up in <code>pavucontrol</code> (after restarting the pipewire-pulse service for the configuration to apply):</p>
<figure><img src="/desksetup/pavucontrol_devices.png" width="1000"/>
</figure>

<p>Selecting the playback device or mircophone phone should now just work like with a locally attached the device. The really nice thing about this is that you can even use the devices from
multiple clients at the same time!!!</p>
<h4 id="webcam">Webcam</h4>
<p>In theory pipewire is was written for camera device sharing between multiple applications. For example the webcam software <code>cheese</code> is already using pipewire. But I have found absolutly
zero infromation if it whould be possible to do that via a network. Im not even really sure that this is on the roadmap. If it is I will definitly revisit this topic. The only other option I could think of was to somehow use some form of continous webcam broadcast that I could then somehow attach as a camera, but I also do not want the webcam to be active all the time.</p>
<p>So the solution I have come up with for now is to use USBIP. Which is a client server application to speak the USB protocol via the network. This comes with the drawback that the webcam
can only be used by one device at a time, but at least I do not have to physically replug the device. Just issue a command to attach and detach it.</p>
<p>This can be done in a few simple steps:</p>
<ol>
<li>Install usbip on server (pi) and client (laptop, desktop)</li>
<li>Enable the Service on both devices.</li>
<li>On pi <code>bind</code> webcam to usbip daemon</li>
<li>Attach/detach webcam via usbip daemon on the client</li>
</ol>
<p>So the first to steps are the same for the client and server: Install the <code>usbip</code> package. Depending on your distribution it might be named differently.
The enable the service using systemd: <code>systemctl enable --now usbipd</code>.</p>
<p>The next step is to bind the webcam to the <code>usbipd</code> daemon on the raspberry pi. For this the busid of the device needs to be found. This can be done by
using the <code>usbip</code> utility:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ usbip list -l
</span></span><span style="display:flex;"><span> - busid 1-1.1 <span style="color:#f92672">(</span>08bb:2902<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   Texas Instruments : PCM2902 Audio Codec <span style="color:#f92672">(</span>08bb:2902<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> - busid 1-1.2 <span style="color:#f92672">(</span>046d:08b6<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   Logitech, Inc. : unknown product <span style="color:#f92672">(</span>046d:08b6<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>The webcam is the logitech device. Binding it to the daemon is as simple as running:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ usbip bind -b 1-1.2
</span></span><span style="display:flex;"><span>usbip: info: bind device on busid 1-1.2: complete
</span></span></code></pre></div><p>Now the device can be attached to the client. First we can also check that the device is availible to be attached:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ usbip list -r 172.16.128.1
</span></span><span style="display:flex;"><span>Exportable USB devices
</span></span><span style="display:flex;"><span><span style="color:#f92672">======================</span>
</span></span><span style="display:flex;"><span> - 172.16.128.1
</span></span><span style="display:flex;"><span>      1-1.2: Logitech, Inc. : unknown product <span style="color:#f92672">(</span>046d:08b6<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>           : /sys/devices/platform/scb/fd500000.pcie/pci0000:00/0000:00:00.0/0000:01:00.0/usb1/1-1/1-1.2
</span></span><span style="display:flex;"><span>           : Miscellaneous Device / ? / Interface Association <span style="color:#f92672">(</span>ef/02/01<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>The <code>-r</code> option is used to specify the remote server running usbip in this case the raspberry pi. Attaching/detaching is done with the commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ sudo usbip attach -r 172.16.128.1 -b 1-1.2
</span></span><span style="display:flex;"><span>$ sudo usbip detach -p <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>With the webcam attached it can be used like any other webcam. For example you could open cheese and take a picture:</p>
<figure><img src="/desksetup/webcam_cheese.jpg" width="1000"/>
</figure>

<p>After usage the webcam should be detached again, to make it possible for other clients to connect to it. If you forget to detach before powering of the device currently using the camera. You
will login to the pi to unbind and rebind the device again, since <code>usbip</code> does not seem to have a timeout mechanism. A few other things to note about this setup are:</p>
<ol>
<li>It is still not possible to use the device from multiple clients at the same time 😥</li>
<li>To make sure that the camera can only be used via the local VLAN a firewall configuration on the pi is required, since usbip is not confuriable to only listen on a certain network interface.</li>
<li>If you are getting an error when attaching the camera, you might also need to make sure the <code>vhci-hcd</code> kernel module is loaded!</li>
</ol>
<p>I hope you enjoyed this post. If you have any further thoughts or questions. Feel free to reach out to me.</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Programming the Raspberry Pi with Rust 🦀]]></title>
    <link href="https://www.felixrichter.tech/posts/rustforraspberrypi/"/>
    <id>https://www.felixrichter.tech/posts/rustforraspberrypi/</id>
    <author>
      <name>Felix Richter</name>
    </author>
	<published>2022-11-25T00:00:00+00:00</published>
	<updated>2022-11-25T00:00:00+00:00</updated>
	<content type="html"><![CDATA[<p>This post serves as a summary for a live code I did at our local hacker space. For the full experience please refer to the <a href="https://youtu.be/iCbES_JHKyM">recording</a>.
Though I probably should warn that the live coding was done in German (and next time I should make sure to increase the font size everywhere for the recording 🙈).</p>
<p>From zero to a working rust project for the raspberry pi. These are the required steps:</p>
<ul>
<li>Setup Rust Project with <code>cargo</code></li>
<li>Install Rust Arm + Raspberry Pi Toolchain</li>
<li>Configure Rust Project for cross compilation</li>
<li>Import crate for GPIO Access</li>
<li>Profit 💰</li>
</ul>
<h2 id="setting-up-a-rust-project">Setting up a Rust Project</h2>
<p>The first step is to setup a rust project. This is easily accomplished by using the rust tooling.
Using cargo it is possible it initialize a hello world rust project:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>&gt; mkdir pi_project
</span></span><span style="display:flex;"><span>&gt; cd pi_project
</span></span><span style="display:flex;"><span>&gt; cargo init
</span></span></code></pre></div><p>This results in the following project structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>pi_project
</span></span><span style="display:flex;"><span>├── Cargo.toml
</span></span><span style="display:flex;"><span>├── .gitignore
</span></span><span style="display:flex;"><span>└── src
</span></span><span style="display:flex;"><span>    └── main.rs
</span></span></code></pre></div><p>Building and running the code is now as simple as running:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>&gt; cargo build
</span></span><span style="display:flex;"><span>&gt; ./target/debug/pi_project
</span></span><span style="display:flex;"><span>Hello, world!
</span></span></code></pre></div><p>Looking at the executable we see that the code was build for the <strong>x86</strong> Architecture.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>&gt; file ./target/debug/pi_project
</span></span><span style="display:flex;"><span>target/debug/pi_project: ELF 64-bit LSB pie executable, x86-64, version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID<span style="color:#f92672">[</span>sha1<span style="color:#f92672">]=</span>0461b95d992ecda8488ad610bb1818344c1eeb8d, <span style="color:#66d9ef">for</span> GNU/Linux 4.4.0, with debug_info, not stripped
</span></span></code></pre></div><p>To be able to run this code on the raspberry pi the target architecture needs to change to <strong>ARM</strong>.</p>
<h2 id="rust-arm-toolchain-setup">Rust Arm Toolchain Setup</h2>
<p>Installing a different target architecture is easy. All that is required is to use rustup. Warning the following list does not mean that your specific pi revision will work, you need to make extra sure to select the correct architecture based on the model of pi you are using! There are differences per revision of the pi.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># for raspberry pi 3/4</span>
</span></span><span style="display:flex;"><span>&gt; rustup target add aarch64-unknown-linux-gnu
</span></span><span style="display:flex;"><span><span style="color:#75715e"># for raspberry pi 1/zero</span>
</span></span><span style="display:flex;"><span>&gt; rustup target add arm-unknown-linux-gnueabihf 
</span></span></code></pre></div><p>This allows telling the cargo to generate <strong>ARM</strong> machine code. This would be all we need if the goal was to write bare metal code.
But just running <strong><code>cargo build --target arm-unknown-linux-gnueabihf</code></strong> results in an error. This because we still need a linker and
the matching system libraries to be able to interface correctly with the Linux kernel running on the pi.</p>
<p>This problem is solved by installing a raspberry pi toolchain. The toolchain can be downloaded from <a href="https://github.com/abhiTronix/raspberry-pi-cross-compilers#-toolchain-downloads">here</a>. They are compatible with the official &ldquo;Raspian OS&rdquo; for the pi. If you are running a different OS on your PI, you may need to look further to find the matching toolchain for your OS.</p>
<p>In this case the pi is running the newest Raspian, which is based on Debian 11:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>&gt; wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Bullseye/GCC%2010.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-10.3.0-pi_0-1.tar.gz/download -O toolchain.tar.gz
</span></span><span style="display:flex;"><span>&gt; tar -xvf toolchain.tar.gz 
</span></span></code></pre></div><h4 id="configure-cross-compilation">Configure cross compilation</h4>
<p>Now the rust build system needs to be configured to use the toolchain. This is done by placing a config file in the project root:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>pi_project
</span></span><span style="display:flex;"><span>├── .cargo
</span></span><span style="display:flex;"><span>│   └── config
</span></span><span style="display:flex;"><span>├── Cargo.lock
</span></span><span style="display:flex;"><span>├── Cargo.toml
</span></span><span style="display:flex;"><span>├── .gitignore
</span></span><span style="display:flex;"><span>└── src
</span></span><span style="display:flex;"><span>    └── main.rs
</span></span></code></pre></div><p>The configuration instructs the cargo build system to use the cross compiler gcc as linker and sets the directory where arm system libraries are located.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span><span style="color:#75715e"># content of .cargo/config</span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">build</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">target</span> = <span style="color:#e6db74">&#34;arm-unknown-linux-gnueabihf&#34;</span> <span style="color:#75715e">#set default target</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#for raspberry pi 1/zero</span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">arm-unknown-linux-gnueabihf</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">linker</span> = <span style="color:#e6db74">&#34;/home/judge/.toolchains/cross-pi-gcc-10.3.0-0/bin/arm-linux-gnueabihf-gcc&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rustflags</span> = [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;-C&#34;</span>, <span style="color:#e6db74">&#34;link-arg=--sysroot=/home/judge/.toolchains/cross-pi-gcc-10.3.0-0/arm-linux-gnueabihf/libc&#34;</span>
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#for raspberry pi 3/4</span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">aarch64-unknown-linux-gnu</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">linker</span> = <span style="color:#e6db74">&#34;/home/judge/.toolchains/cross-pi-gcc-10.3.0-64/bin/aarch64-linux-gnu-gcc&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rustflags</span> = [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;-C&#34;</span>, <span style="color:#e6db74">&#34;link-arg=--sysroot=/home/judge/.toolchains/cross-pi-gcc-10.3.0-0/aarch64-linux-gnu/libc&#34;</span>
</span></span><span style="display:flex;"><span>]
</span></span></code></pre></div><p>This sets the default target of the project to <strong><code>arm-unknown-linux-gnueabihf</code></strong>, now running <strong><code>cargo build</code></strong> results in the following <strong>ARM</strong> binary being created.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>file target/arm-unknown-linux-gnueabihf/debug/pi_project
</span></span><span style="display:flex;"><span>target/arm-unknown-linux-gnueabihf/debug/pi_project: ELF 32-bit LSB pie executable, ARM, EABI5 version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, dynamically linked, interpreter /lib/ld-linux-armhf.so.3, <span style="color:#66d9ef">for</span> GNU/Linux 3.2.0, with debug_info, not stripped
</span></span></code></pre></div><p>It can now be copied to the raspberry pi and be executed.</p>
<h2 id="gpio-access">GPIO Access</h2>
<p>Until this point the source of the application was not touched. This changes now because just executing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// contents of src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Hello World!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>is boring! If we have a raspberry pi it would be much more fun to use it to control some hardware 💪.
Thankfully there already is a library that we can use to do just that. <a href="https://crates.io/crates/rppal">rppal</a> enables
access to the GPIO pins of the pi. Including the library in the project requires declaring it as a dependency in the
<strong><code>Cargo.toml</code></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rppal</span> = <span style="color:#e6db74">&#34;0.14.0&#34;</span>
</span></span></code></pre></div><p>Now we can use the library to make an led blink.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::time::Duration;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> rppal::gpio::Gpio;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Gpio uses BCM pin numbering. BCM GPIO 23 is tied to physical pin 16.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">GPIO_LED</span>: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">23</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> gpio <span style="color:#f92672">=</span> Gpio::new().expect(<span style="color:#e6db74">&#34;Unable to access GPIO!&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> pin <span style="color:#f92672">=</span> gpio.get(<span style="color:#66d9ef">GPIO_LED</span>).unwrap().into_output();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        pin.toggle();
</span></span><span style="display:flex;"><span>        thread::sleep(Duration::from_millis(<span style="color:#ae81ff">500</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And that&rsquo;s basically it. Now we can use rust to program the raspberry pi to do any task we want. We can even get fancy and use
an async runtime to execute many tasks in parallel.</p>
<p>I hope this summary is useful to you and feel free to contact me if you have questions or find this post useful.</p>
<p>Happy coding 🧑‍💻 …</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Using Boundary Scan for PCB debugging]]></title>
    <link href="https://www.felixrichter.tech/posts/jtaghardwaredebugging/"/>
    <id>https://www.felixrichter.tech/posts/jtaghardwaredebugging/</id>
    <author>
      <name>Felix Richter</name>
    </author>
	<published>2020-03-29T00:00:00+00:00</published>
	<updated>2020-03-29T00:00:00+00:00</updated>
	<content type="html"><![CDATA[<p>I did a seminar talk on JTAG and how to use it to check a PCB for errors. For
this i designed a little board in order to simulate manufacturing errors. In this
post I want to give you a short introduction to JTAG and how to use it.</p>
<h1 id="what-is-boundary-scan">What is Boundary-scan</h1>
<p>Boundary-scan was developed to simplify testing of integrated circuits. To do this
the Joint Test Action Group introduced the Boundary Scan architecture as a standard
and today it has replaced the old testing methods because of its cost efficiency and speed
up of test development and execution.</p>
<h3 id="so-how-does-this-work">So how does this work?</h3>
<p>I will be just covering the basics here. If you want a more detailed introduction, you can read the articles referenced
at the end of this post.</p>
<p>Boundary-scan is a technology which places cells at the circuits boundary that can sample the circuit inputs and
also drive its outputs. This can be done while the circuit is operating and it is controlled via the JTAG interface.
With these cells in place we wan test the internal logic of the circuit as well as the interconnects between
the devices on a board.</p>
<figure><img src="/jtag_debug/bs_register.png" width="400"/>
</figure>

<p>In the picture above you can see an overview of the boundary-scan architecture. This picture only shows one JTAG device, but
on more complex PCB there are many such devices that are connected in a JTAG chain. This means that the data out of one
chip is connected to the input of the next.</p>
<p>In order for us use this architecture, we need to connect to the four JTAG pins:</p>
<ul>
<li><strong>TDI</strong> Test Data In</li>
<li><strong>TDO</strong> Test Data Out</li>
<li><strong>TCK</strong> Test Clock</li>
<li><strong>TMS</strong> Test Mode Select</li>
</ul>
<p>Once connected we can control all of the devices in the JTAG chain. In general we can perform two different types
of actions. We can either write/read data or we can write instructions. Testing a circuit involves both of theses
actions. By writing instructions we can set the connected circuits into different modes. And by writing data
we can set the pins to the desired levels as well as read the results.</p>
<p>There are three different instructions we are interested in when testing interconnects:</p>
<ul>
<li><strong>SAMPLE/PRELOAD</strong></li>
<li><strong>EXTEST</strong></li>
<li><strong>BYPASS</strong></li>
</ul>
<p>With the <strong>SAMPLE/PRELOAD</strong> instruction the boundary-scan cells will sample the inputs of the circuit, and when shifting in
data we can read values received at the pins. We can also use this command to load data into the boundary-scan cells. The
<strong>EXTEST</strong> instruction will set the output of the pins to the values provided in the boundary-scan cells and the <strong>BYPASS</strong>
instruction lets us skip devices in the chain that are not of interest to the test currently performed.</p>
<p>With these instructions we can set pins of a device to a logic level and test at the receiving circuit if the correct logic
level was received.</p>
<h1 id="the-hardware">The Hardware</h1>
<p>We need to connect to the JTAG pins of a devices. If they are exposed there probably is a connector on the board. If not it may
be possible to solder wires directly to the pins. In any case we will need a JTAG adapter in order to connect them to a normal
computer via USB. I am using a JLink adapter which features a 20 pin JTAG connector.</p>
<p>The PCB I am using for testing is a small circuit I designed myself, it also has a 20 pin connector which exposes the JTAG pins.
Here is the layout:</p>
<figure><img src="/jtag_debug/board_schem.png" width="600"/>
</figure>

<p>It features two MAX V Altera CPLDs that implement the boundary-scan architecture and are connected in a JTAG chain.
To test some connections between them I connected eight of their pins at the top and added a dip switch to simulate
shorts between the wires as well as pull ups and pull downs.</p>
<h1 id="tooling">Tooling</h1>
<p>Okay so we got a PCB and connected it to a computer with a JTAG adapter now what? How do get the tests running?</p>
<p>Well this is where it gets hard, because there is no nice open source software that does it all for us. We need to write the
test ourselves and for that we need to know the details of the interconnects on our PCB and the details of how the boundary-scan
architecture is implemented in the devices in our JTAG chain.</p>
<h2 id="bsdl-files">BSDL Files</h2>
<p>The Boundary-scan standard does not tell manufacturers what bit codes to use to encode the instructions, but it does require
them to publish the so called BSDL (Boundary Scan Description Language) files free of charge for their devices. These files
use a dialect derived from VHDL a hardware description language and describe all information needed to use a devices
boundary-scan architecture. For example:</p>
<ul>
<li>Instruction register description</li>
<li>Boundary-scan cell description</li>
<li>Pin mappings</li>
<li>and more</li>
</ul>
<p>Basically all information we might want to know about a specific device is in that file.</p>
<h2 id="svf-files">SVF Files</h2>
<p>Most JTAG adapter tool chains support a file format called SVF (Serial Vector Format). These are plain text files that describe
what data or instructions to write to the JTAG connection. It has no knowledge about the JTAG chain of devices or any of
there properties. We can just specify what data/instructions to shift in and what results we expect to be shifted out.</p>
<h2 id="designing-a-simple-test">Designing a simple test</h2>
<p>Okay so putting it all together. Lets say we want to test two neighboring interconnects for a bridging fault.</p>
<p>On my example PCB two neighboring interconnects are connected as follows:</p>
<ol>
<li>CHIP 1 <strong>IO56</strong> -  CHIP 2 <strong>IO49</strong></li>
<li>CHIP 1 <strong>IO55</strong> -  CHIP 2 <strong>IO50</strong></li>
</ol>
<p>So if we set <strong>IO56</strong> of the first chip to a logic 1 and <strong>IO55</strong> to logic 0, we would expect to receive a logic 1 on <strong>IO49</strong>
and a logic 0 at <strong>IO50</strong> on the second chip. If we receive a logic 1 at <strong>IO50</strong> that means that there is a bridging fault between
the interconnects.</p>
<p>To write a test for this we need to write an SVF file that we can run with the JTAG adapter tool chain. It needs to complete the
following steps:</p>
<ol>
<li>Set first chip into <strong>SAMPLE/PRELOAD</strong> mode. (Shift in Instructions)</li>
<li>Load Test pattern into first chip (Shift in Data)</li>
<li>Set first chip to <strong>EXTEST</strong> and second chip to <strong>SAMPLE/PRELOAD</strong> mode (Shift in Instructions)</li>
<li>Shift in dummy data to receive the data sampled from chip 2 and compare against the expected result (Shift in Data)</li>
</ol>
<p>The following SVF files does exactly this:</p>
<pre tabindex="0"><code class="language-svf" data-lang="svf">TRST OFF;
ENDIR IDLE;
ENDDR IDLE;
STATE RESET;
STATE IDLE;
FREQUENCY 10000000 HZ;
SIR 20 TDI (01405);
SDR 480 TDI (000000000000000000000000000000000000000000800000000000000
	000000000000000000000000000000000000000000000000000000000000000);
SIR 20 TDI (03c05);
SDR 480 TDI (0) TDO (000000000000000000000000000000000000000000000000
	00000000000000000000000000000000000000000000000100000000000000000
	0000000) MASK (00000000000000000000000000000000000000000000000000
	00000000000000000000000000000000000000000000012000000000000000000
	00000);
</code></pre><p>Up until the first line starting with <em>SIR</em> all we are doing is making sure the boundary-scan circuit is in a known state and setting the
speed at which we want to operate.</p>
<p><strong>SIR</strong> means we want to write instruction data. We need to specify the length and since we have to chips with both 10 bit instruction registers
we are writing 20 bits of data. The data we want to write is specified behind the <em>TDI</em> statement as a hex string surrounded by parenthesis.</p>
<p><strong>SDR</strong> works the same as <em>SIR</em> but instead of instruction data we are just writing data. In this case we are writing 480 bits, since
both chips have a boundary-scan register length of 240 bits. If we want to compare the shifted out data against the expected data
we have to write the expected result as a hex string behind the <em>TDO</em> statement and we can even mask the result so that we only look
at the bits we are interested in.</p>
<p>How do we know what data to write and what data to expect? Well for that we have to look at the BSDL files of the devices in our
JTAG chain and figure out which pin is mapped to which bit in the data. Of course writing a SVF by hand is very tedious, so instead
I created some <a href="https://github.com/ju6ge/jtag_testing">python scripts</a> to help me with the task. Feel free to use them for your
own projects.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Using Boundary-scan for PCB testing is very nice when trying to automatically test PCBs. Sadly there is little to no open source
software which makes it easy to design tests for your own layouts. Which means that you still have to do a lot of information gathering
if you want to use this technology. But once the tests are implemented testing a PCB becomes a very easy and fast.</p>
<p>I hope this blog post gave you an idea of what you need to do, to get up and running with boundary-scan testing. If you have any feedback
feel free to contact me.</p>
<h3 id="further-reading-material">Further Reading Material</h3>
<ul>
<li><a href="http://www.ti.com/lit/an/ssya002c/ssya002c.pdf">Texas Instruments Testabilty Primer</a></li>
<li><a href="https://pdfs.semanticscholar.org/9acb/ea9b3ddd1a80a01434d32912821837bd9af3.pdf">Paper on Interconnect Testing</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Introduction to Hardware Peripherals]]></title>
    <link href="https://www.felixrichter.tech/posts/hardwareperipherals/"/>
    <id>https://www.felixrichter.tech/posts/hardwareperipherals/</id>
    <author>
      <name>Felix Richter</name>
    </author>
	<published>2019-12-27T00:00:00+00:00</published>
	<updated>2019-12-27T00:00:00+00:00</updated>
	<content type="html"><![CDATA[<p>Lately I have been doing programming for embedded systems such as the
esp32 and esp8266, and additionally I did a course on embedded systems for
my masters degree. This introduced me to the wonderful world of programming
close to the hardware level, and inspired me to write this post about
hardware peripherals.</p>
<h1 id="what-are-hardware-peripherals">What are Hardware Peripherals?</h1>
<p>Hardware Peripherals are specialized pieces of silicon that are built into
a processor. They are used to perform a diverse set of task. This includes
controlling the processors clock speed, power management and communication
with other devices. They are responsible for configuring the device operation
and during operation are used to perform tasks in parallel with the main
cores.</p>
<h4 id="so-what-can-these-peripherals-do">So what can these peripherals do?</h4>
<p>Anyone who has ever looked into the data sheet of a microprocessor will know
that these data sheets are long. The data sheet for the ARM cortex m7 CPU for
example is about 2000 pages long. Which is to say that there are a lot of
peripherals that can do a variety of things, for example:</p>
<ul>
<li><strong>Analog Digital Converters (ADC)</strong> used for measuring analog signals</li>
<li><strong>Direct Memory Access Controllers (DMA)</strong> used for copying data from sensor to memory or the other way</li>
<li><strong>GPIO Interfaces</strong> used for pin management</li>
<li><strong>I2C and SPI Interfaces</strong> used for communicating with sensor devices</li>
<li><strong>PMC</strong> the power management controller</li>
<li>Other Memory interfaces such as PCI or EBI</li>
</ul>
<h1 id="using-peripherals">Using Peripherals</h1>
<p>In order for us to use a peripheral, we have to complete a few steps:</p>
<ol>
<li>
<p>Setup peripheral mode</p>
</li>
<li>
<p>Start peripheral task</p>
</li>
<li>
<p>Wait for peripheral to finish</p>
</li>
</ol>
<p>All of this is done via memory mapped registers, which is to say that
within the memory range of the processor there are dedicated areas of memory
that do not map to a memory controller like an SDRAM, but are mapped to
registers belonging to the peripherals. The peripherals use these registers
as configuration values that change how the peripheral is working or if it
is running, and some of the registers are not meant to be written to but
instead are used to communicate the status of the peripheral back to the CPU.</p>
<p>All of this is described in the data sheet of the processor you are using. Every
peripheral has a section describing what it can do, and what parameters can
be changed via the memory mapped registers, as well as how the peripheral
can be started, stopped and how to know when it is finished.</p>
<p>Since all of this is highly dependent on the platform you are using, it is
hard to give you a clear cut way to use any peripheral. You will always have
to refer back to the data sheet and look how to use the peripheral for your
platform. But in order for you to get an idea on how to do this, let us look
at an example.</p>
<h2 id="example">Example</h2>
<p>Every example is specific to the specific device we are using. For
these examples we are going to look at the simple case of toggling
a GPIO pin. The chip we are using is an embedded cortex m7 cpu,
from atmel. It belongs to the atsame70 family of cpu&rsquo;s.
<a href="http://ww1.microchip.com/downloads/en/DeviceDoc/SAM-E70-S70-V70-V71-Family-Data-Sheet-DS60001527D.pdf">Datasheet</a></p>
<p>So all we want to do is let a led blink. To do this we will have to toggle
the status of a pin, and all pins are managed by the GPIO peripheral. In the
data sheet of this particular chip this peripheral is just called PIO. To be
able to do this we first have to tell the PIO peripheral that it should take
control of the pin and then tell it to configure the pin to be used as an
output. After that we can change the pin state.</p>
<p>If you already looked into the data sheet you might have noticed so that there
are multiple PIO peripherals and how the pins are mapped depends on the rest
of the system. For the system that i am programming a led is connected
to pin <strong>19</strong> on PIO <strong>C</strong>. So this is the pin I will be using in this example.</p>
<p>To achive an accurate timeout between turning the led on and off, we are
going to use the real time timer peripheral on our device. It is in essence
a configurable counter attached to a clock signal.</p>
<h3 id="let-us-do-this-in-c">Let us do this in C</h3>
<p>This example uses the C library provided by atmel which provides the correct
memory addresses of the peripherals and exposes them to us as definitions and
structures. By just using these we are automatically writing to the correct
addresses.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;atsame70.h&#34; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">timeout_ms</span>(<span style="color:#66d9ef">int</span> ms) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// restart timer and set prescaler to count every 32 clock cycles 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// this corresponds to a 1ms clock cycle since the clock frequency is 32 kHz 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		RTT<span style="color:#f92672">-&gt;</span>RTT_MR <span style="color:#f92672">=</span> <span style="color:#a6e22e">RTT_MR_RTPRES</span>(<span style="color:#ae81ff">0x20</span>) <span style="color:#f92672">|</span> RTT_MR_RTTRST; 
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> ( (RTT<span style="color:#f92672">-&gt;</span>RTT_VR <span style="color:#f92672">|</span> RTT_VR_CRTV_Msk) <span style="color:#f92672">&lt;</span> ms) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//wait for counter to have counted to desired timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">blink_led</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//give control of the pin to the pio -&gt; basically the running code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ATSAME70_BASE_PIOC<span style="color:#f92672">-&gt;</span>PIO_PER <span style="color:#f92672">=</span> PIO_PC19; 
</span></span><span style="display:flex;"><span>		ATSAME70_BASE_PIOC<span style="color:#f92672">-&gt;</span>PIO_OER <span style="color:#f92672">=</span> PIO_PC19;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span>(true) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//turn led on 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ATSAME70_BASE_PIOC<span style="color:#f92672">-&gt;</span>PIO_SODR <span style="color:#f92672">=</span> PIO_PC19;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">timeout_ms</span>(<span style="color:#ae81ff">500</span>); 
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//turn led off 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ATSAME70_BASE_PIOC<span style="color:#f92672">-&gt;</span>PIO_CODR <span style="color:#f92672">=</span> PIO_PC19; 
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">timeout_ms</span>(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="timeouts">Timeouts</h4>
<p>Since the device can vary it&rsquo;s clock speed it is not desirable to implement a
delay with just waiting a specified amount of clock cycles. Instead we
are going to use the atsame70 <em>Real Time Timer</em> (RTT).</p>
<p>How to configure the RTT correctly can be read in the functional description in
the data sheet. In short we have to configure the clock source since there are
two at different speeds. Scale how many clock cycles trigger the counter and
reset the peripheral for the new setting to take affect.</p>
<p>To do this we have to write to a memory mapped register:</p>
<figure><img src="/hardware_peripherals/rtt_reg.png"/>
</figure>

<p>In the figure we can see all the registers that are connected to the RTT. All
the values we need to configure are in the RTT_MR register. It is basically just
a 32 bit value. But every bit has a meaning. The first 16 bits represent the 16
bit prescaler value, and there is also a bit to enable the peripheral and one to
the reset it. Selecting the clock source is also done with one bit.</p>
<p>So what do we need to wait for a certain amount of ms:</p>
<ol>
<li>
<p>Select the 32kHz clock src by setting the <strong>RTC1HZ</strong> bit in <strong>RTT_MR</strong> to <strong>0</strong></p>
</li>
<li>
<p>Setting the <strong>RTPRES</strong> 16 bit value to <strong>32</strong> in order for the counter to increase ever 32 clock cycles
which corresponds to increase the counter value evey 1ms</p>
</li>
<li>
<p>Set the <strong>RTTDIS</strong> bit to <strong>0</strong> to not disable the rtt</p>
</li>
<li>
<p>Trigger the RTT reset by setting <strong>RTTRST</strong> bit to <strong>1</strong></p>
</li>
</ol>
<p>All of these 4 steps can be done with one write to the <strong>RTT_MR</strong> register.</p>
<p>Afterwards the timer is running and we can read the value in <strong>RTT_VR</strong> to see how
much time has passed.</p>
<h4 id="controlling-the-led">Controlling the LED</h4>
<p>The PIO peripheral that manages the pins of the device is a lot more complex than the RTT peripheral. Which
means it has many more registers. Using these we can do fancy things like giving other peripherals such as
the SPI peripheral control over the pins it needs to communicate.</p>
<p>But we are just interested in simply controlling a pin ourselfs. For this we need 4 different registers:</p>
<ol>
<li>
<p><strong>PIO_PER</strong> peripheral enable register</p>
</li>
<li>
<p><strong>PIO_OER</strong> peripheral output enable register</p>
</li>
<li>
<p><strong>PIO_SODR</strong> set output data register</p>
</li>
<li>
<p><strong>PIO_CODR</strong> clear output data register</p>
</li>
</ol>
<p>They all have the same structure so i am just going to show you one of them:</p>
<figure><img src="/hardware_peripherals/pio_reg.png"/>
</figure>

<p>Basically for every pin controlled by the PIO there is a bit. So one PIO gives us control over 32 pins.
To control a pin we have to do the following steps:</p>
<ol>
<li>
<p>set <strong>PIO_PER</strong> pin bit to <em>1</em> to enable control of the PIO over the pin</p>
</li>
<li>
<p>set <strong>PIO_OER</strong> pin bit to <em>1</em> to set the pin into output mode</p>
</li>
</ol>
<p>Now setting the <strong>PIO_SODR</strong> pin bit to <em>1</em> to pull the pin high and setting the <strong>PIO_CODR</strong> pin bit to <em>1</em> pulls the pin low again.</p>
<h3 id="how-does-all-of-this-look-in-rust">How does all of this look in Rust</h3>
<p>For rust there is no official library from atmel, but there is a project
called svd2rust that allows us to auto-generate a library that we can use
to address the correct peripheral registers. All we need is the svd file of
the processor we are using, this is an xml file describing all the peripherals
and their register values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>	<span style="color:#66d9ef">use</span> atsame70q21::{Peripherals}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">timeout_ms</span>(peripherals : <span style="color:#66d9ef">&amp;</span> <span style="color:#a6e22e">Peripherals</span>, <span style="color:#66d9ef">u32</span> ms) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> rtt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>peripherals.<span style="color:#66d9ef">RTT</span>;
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// restart timer and set prescaler to count every 32 clock cycles 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// this corresponds to a 1ms clock cycle since the clock frequency is 32 kHz 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		rtt.rtt_mr.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsafe</span> {w.rtpres().bits(<span style="color:#ae81ff">0x20</span>);}
</span></span><span style="display:flex;"><span>			w.rttdis().clearbit();
</span></span><span style="display:flex;"><span>			w.rttrst().set_bit()
</span></span><span style="display:flex;"><span>		});
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> rtt.rtt_vr.read().crtv().bits() <span style="color:#f92672">&lt;</span> ms {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// wait for counter to have counted to desired timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">blink_led</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> peripherals <span style="color:#f92672">=</span> Peripherals::take().unwrap();
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> pioc <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>peripherals.<span style="color:#66d9ef">PIOC</span>;
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//give control of the pin to the pio -&gt; basically the running code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		pioc.pio_per.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> w.p19().set_bit() );
</span></span><span style="display:flex;"><span>		pioc.pio_oer.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> w.p19().set_bit() );
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">loop</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//turn led on 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pioc.pio_sodr.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> w.p19().set_bit() );
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			timeout_ms(<span style="color:#f92672">&amp;</span>peripherals, <span style="color:#ae81ff">500</span>); 
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//turn led off 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pioc.pio_codr.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> w.p19().set_bit() );
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			timeout_ms(<span style="color:#f92672">&amp;</span>peripherals, <span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>The logic of the rust code is exactly the same as the C example, and since all of the actual functionality we are using
is provided by the hardware and not by the language specifics the code looks mostly the same.</p>
<p>I hope you liked this little excursion into bare metal programming, i am sure i will return with more blog post regarding
similar topics while i keep experimenting more with rust on bare metal systems.</p>
]]></content>
  </entry>
</feed>
