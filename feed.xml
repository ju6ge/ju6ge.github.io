<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Felix Richter Website</title>
  <link href="https://www.felixrichter.tech/feed.xml" rel="self"/>
  <link href="https://www.felixrichter.tech/"/>
  <updated>2022-11-25T00:00:00+00:00</updated>
  <id>https://www.felixrichter.tech/</id>
  <generator>Hugo -- gohugo.io</generator>
  <entry>
    <title type="html"><![CDATA[Programming the Raspberry Pi with Rust 🦀]]></title>
    <link href="https://www.felixrichter.tech/posts/rustforraspberrypi/"/>
    <id>https://www.felixrichter.tech/posts/rustforraspberrypi/</id>
    <author>
      <name>Felix Richter</name>
    </author>
	<published>2022-11-25T00:00:00+00:00</published>
	<updated>2022-11-25T00:00:00+00:00</updated>
	<content type="html"><![CDATA[<p>This post serves as a summary for a live code I did at our local hacker space. For the full experience please refer to the <a href="https://youtu.be/iCbES_JHKyM">recording</a>.
Though I probably should warn that the live coding was done in German (and next time I should make sure to increase the font size everywhere for the recording 🙈).</p>
<p>From zero to a working rust project for the raspberry pi. These are the required steps:</p>
<ul>
<li>Setup Rust Project with <code>cargo</code></li>
<li>Install Rust Arm + Raspberry Pi Toolchain</li>
<li>Configure Rust Project for cross compilation</li>
<li>Import crate for GPIO Access</li>
<li>Profit 💰</li>
</ul>
<h2 id="setting-up-a-rust-project">Setting up a Rust Project</h2>
<p>The first step is to setup a rust project. This is easily accomplished by using the rust tooling.
Using cargo it is possible it initialize a hello world rust project:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>&gt; mkdir pi_project
</span></span><span style="display:flex;"><span>&gt; cd pi_project
</span></span><span style="display:flex;"><span>&gt; cargo init
</span></span></code></pre></div><p>This results in the following project structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>pi_project
</span></span><span style="display:flex;"><span>├── Cargo.toml
</span></span><span style="display:flex;"><span>├── .gitignore
</span></span><span style="display:flex;"><span>└── src
</span></span><span style="display:flex;"><span>    └── main.rs
</span></span></code></pre></div><p>Building and running the code is now as simple as running:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>&gt; cargo build
</span></span><span style="display:flex;"><span>&gt; ./target/debug/pi_project
</span></span><span style="display:flex;"><span>Hello, world!
</span></span></code></pre></div><p>Looking at the executable we see that the code was build for the <strong>x86</strong> Architecture.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>&gt; file ./target/debug/pi_project
</span></span><span style="display:flex;"><span>target/debug/pi_project: ELF 64-bit LSB pie executable, x86-64, version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID<span style="color:#f92672">[</span>sha1<span style="color:#f92672">]=</span>0461b95d992ecda8488ad610bb1818344c1eeb8d, <span style="color:#66d9ef">for</span> GNU/Linux 4.4.0, with debug_info, not stripped
</span></span></code></pre></div><p>To be able to run this code on the raspberry pi the target architecture needs to change to <strong>ARM</strong>.</p>
<h2 id="rust-arm-toolchain-setup">Rust Arm Toolchain Setup</h2>
<p>Installing a different target architecture is easy. All that is required is to use rustup. Warning the following list does not mean that your specific pi revision will work, you need to make extra sure to select the correct architecture based on the model of pi you are using! There are differences per revision of the pi.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># for raspberry pi 3/4</span>
</span></span><span style="display:flex;"><span>&gt; rustup target add aarch64-unknown-linux-gnu
</span></span><span style="display:flex;"><span><span style="color:#75715e"># for raspberry pi 1/zero</span>
</span></span><span style="display:flex;"><span>&gt; rustup target add arm-unknown-linux-gnueabihf 
</span></span></code></pre></div><p>This allows telling the cargo to generate <strong>ARM</strong> machine code. This would be all we need if the goal was to write bare metal code.
But just running <strong><code>cargo build --target arm-unknown-linux-gnueabihf</code></strong> results in an error. This because we still need a linker and
the matching system libraries to be able to interface correctly with the Linux kernel running on the pi.</p>
<p>This problem is solved by installing a raspberry pi toolchain. The toolchain can be downloaded from <a href="https://github.com/abhiTronix/raspberry-pi-cross-compilers#-toolchain-downloads">here</a>. They are compatible with the official &ldquo;Raspian OS&rdquo; for the pi. If you are running a different OS on your PI, you may need to look further to find the matching toolchain for your OS.</p>
<p>In this case the pi is running the newest Raspian, which is based on Debian 11:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>&gt; wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Bullseye/GCC%2010.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-10.3.0-pi_0-1.tar.gz/download -O toolchain.tar.gz
</span></span><span style="display:flex;"><span>&gt; tar -xvf toolchain.tar.gz 
</span></span></code></pre></div><h4 id="configure-cross-compilation">Configure cross compilation</h4>
<p>Now the rust build system needs to be configured to use the toolchain. This is done by placing a config file in the project root:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>pi_project
</span></span><span style="display:flex;"><span>├── .cargo
</span></span><span style="display:flex;"><span>│   └── config
</span></span><span style="display:flex;"><span>├── Cargo.lock
</span></span><span style="display:flex;"><span>├── Cargo.toml
</span></span><span style="display:flex;"><span>├── .gitignore
</span></span><span style="display:flex;"><span>└── src
</span></span><span style="display:flex;"><span>    └── main.rs
</span></span></code></pre></div><p>The configuration instructs the cargo build system to use the cross compiler gcc as linker and sets the directory where arm system libraries are located.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span><span style="color:#75715e"># content of .cargo/config</span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">build</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">target</span> = <span style="color:#e6db74">&#34;arm-unknown-linux-gnueabihf&#34;</span> <span style="color:#75715e">#set default target</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#for raspberry pi 1/zero</span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">arm-unknown-linux-gnueabihf</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">linker</span> = <span style="color:#e6db74">&#34;/home/judge/.toolchains/cross-pi-gcc-10.3.0-0/bin/arm-linux-gnueabihf-gcc&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rustflags</span> = [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;-C&#34;</span>, <span style="color:#e6db74">&#34;link-arg=--sysroot=/home/judge/.toolchains/cross-pi-gcc-10.3.0-0/arm-linux-gnueabihf/libc&#34;</span>
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#for raspberry pi 3/4</span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">aarch64-unknown-linux-gnu</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">linker</span> = <span style="color:#e6db74">&#34;/home/judge/.toolchains/cross-pi-gcc-10.3.0-64/bin/aarch64-linux-gnu-gcc&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rustflags</span> = [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;-C&#34;</span>, <span style="color:#e6db74">&#34;link-arg=--sysroot=/home/judge/.toolchains/cross-pi-gcc-10.3.0-0/aarch64-linux-gnu/libc&#34;</span>
</span></span><span style="display:flex;"><span>]
</span></span></code></pre></div><p>This sets the default target of the project to <strong><code>arm-unknown-linux-gnueabihf</code></strong>, now running <strong><code>cargo build</code></strong> results in the following <strong>ARM</strong> binary being created.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>file target/arm-unknown-linux-gnueabihf/debug/pi_project
</span></span><span style="display:flex;"><span>target/arm-unknown-linux-gnueabihf/debug/pi_project: ELF 32-bit LSB pie executable, ARM, EABI5 version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, dynamically linked, interpreter /lib/ld-linux-armhf.so.3, <span style="color:#66d9ef">for</span> GNU/Linux 3.2.0, with debug_info, not stripped
</span></span></code></pre></div><p>It can now be copied to the raspberry pi and be executed.</p>
<h2 id="gpio-access">GPIO Access</h2>
<p>Until this point the source of the application was not touched. This changes now because just executing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// contents of src/main.rs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;Hello World!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>is boring! If we have a raspberry pi it would be much more fun to use it to control some hardware 💪.
Thankfully there already is a library that we can use to do just that. <a href="https://crates.io/crates/rppal">rppal</a> enables
access to the GPIO pins of the pi. Including the library in the project requires declaring it as a dependency in the
<strong><code>Cargo.toml</code></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rppal</span> = <span style="color:#e6db74">&#34;0.14.0&#34;</span>
</span></span></code></pre></div><p>Now we can use the library to make an led blink.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::time::Duration;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> rppal::gpio::Gpio;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Gpio uses BCM pin numbering. BCM GPIO 23 is tied to physical pin 16.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> GPIO_LED: <span style="color:#66d9ef">u8</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">23</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> gpio <span style="color:#f92672">=</span> Gpio::new().expect(<span style="color:#e6db74">&#34;Unable to access GPIO!&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> pin <span style="color:#f92672">=</span> gpio.get(GPIO_LED).unwrap().into_output();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        pin.toggle();
</span></span><span style="display:flex;"><span>        thread::sleep(Duration::from_millis(<span style="color:#ae81ff">500</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And that&rsquo;s basically it. Now we can use rust to program the raspberry pi to do any task we want. We can even get fancy and use
an async runtime to execute many tasks in parallel.</p>
<p>I hope this summary is useful to you and feel free to contact me if you have questions or find this post useful.</p>
<p>Happy coding 🧑‍💻 …</p>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Using Boundary Scan for PCB debugging]]></title>
    <link href="https://www.felixrichter.tech/posts/jtaghardwaredebugging/"/>
    <id>https://www.felixrichter.tech/posts/jtaghardwaredebugging/</id>
    <author>
      <name>Felix Richter</name>
    </author>
	<published>2020-03-29T00:00:00+00:00</published>
	<updated>2020-03-29T00:00:00+00:00</updated>
	<content type="html"><![CDATA[<p>I did a seminar talk on JTAG and how to use it to check a PCB for errors. For
this i designed a little board in order to simulate manufacturing errors. In this
post I want to give you a short introduction to JTAG and how to use it.</p>
<h1 id="what-is-boundary-scan">What is Boundary-scan</h1>
<p>Boundary-scan was developed to simplify testing of integrated circuits. To do this
the Joint Test Action Group introduced the Boundary Scan architecture as a standard
and today it has replaced the old testing methods because of its cost efficiency and speed
up of test development and execution.</p>
<h3 id="so-how-does-this-work">So how does this work?</h3>
<p>I will be just covering the basics here. If you want a more detailed introduction, you can read the articles referenced
at the end of this post.</p>
<p>Boundary-scan is a technology which places cells at the circuits boundary that can sample the circuit inputs and
also drive its outputs. This can be done while the circuit is operating and it is controlled via the JTAG interface.
With these cells in place we wan test the internal logic of the circuit as well as the interconnects between
the devices on a board.</p>
<figure><img src="/jtag_debug/bs_register.png" width="400"/>
</figure>

<p>In the picture above you can see an overview of the boundary-scan architecture. This picture only shows one JTAG device, but
on more complex PCB there are many such devices that are connected in a JTAG chain. This means that the data out of one
chip is connected to the input of the next.</p>
<p>In order for us use this architecture, we need to connect to the four JTAG pins:</p>
<ul>
<li><strong>TDI</strong> Test Data In</li>
<li><strong>TDO</strong> Test Data Out</li>
<li><strong>TCK</strong> Test Clock</li>
<li><strong>TMS</strong> Test Mode Select</li>
</ul>
<p>Once connected we can control all of the devices in the JTAG chain. In general we can perform two different types
of actions. We can either write/read data or we can write instructions. Testing a circuit involves both of theses
actions. By writing instructions we can set the connected circuits into different modes. And by writing data
we can set the pins to the desired levels as well as read the results.</p>
<p>There are three different instructions we are interested in when testing interconnects:</p>
<ul>
<li><strong>SAMPLE/PRELOAD</strong></li>
<li><strong>EXTEST</strong></li>
<li><strong>BYPASS</strong></li>
</ul>
<p>With the <strong>SAMPLE/PRELOAD</strong> instruction the boundary-scan cells will sample the inputs of the circuit, and when shifting in
data we can read values received at the pins. We can also use this command to load data into the boundary-scan cells. The
<strong>EXTEST</strong> instruction will set the output of the pins to the values provided in the boundary-scan cells and the <strong>BYPASS</strong>
instruction lets us skip devices in the chain that are not of interest to the test currently performed.</p>
<p>With these instructions we can set pins of a device to a logic level and test at the receiving circuit if the correct logic
level was received.</p>
<h1 id="the-hardware">The Hardware</h1>
<p>We need to connect to the JTAG pins of a devices. If they are exposed there probably is a connector on the board. If not it may
be possible to solder wires directly to the pins. In any case we will need a JTAG adapter in order to connect them to a normal
computer via USB. I am using a JLink adapter which features a 20 pin JTAG connector.</p>
<p>The PCB I am using for testing is a small circuit I designed myself, it also has a 20 pin connector which exposes the JTAG pins.
Here is the layout:</p>
<figure><img src="/jtag_debug/board_schem.png" width="600"/>
</figure>

<p>It features two MAX V Altera CPLDs that implement the boundary-scan architecture and are connected in a JTAG chain.
To test some connections between them I connected eight of their pins at the top and added a dip switch to simulate
shorts between the wires as well as pull ups and pull downs.</p>
<h1 id="tooling">Tooling</h1>
<p>Okay so we got a PCB and connected it to a computer with a JTAG adapter now what? How do get the tests running?</p>
<p>Well this is where it gets hard, because there is no nice open source software that does it all for us. We need to write the
test ourselves and for that we need to know the details of the interconnects on our PCB and the details of how the boundary-scan
architecture is implemented in the devices in our JTAG chain.</p>
<h2 id="bsdl-files">BSDL Files</h2>
<p>The Boundary-scan standard does not tell manufacturers what bit codes to use to encode the instructions, but it does require
them to publish the so called BSDL (Boundary Scan Description Language) files free of charge for their devices. These files
use a dialect derived from VHDL a hardware description language and describe all information needed to use a devices
boundary-scan architecture. For example:</p>
<ul>
<li>Instruction register description</li>
<li>Boundary-scan cell description</li>
<li>Pin mappings</li>
<li>and more</li>
</ul>
<p>Basically all information we might want to know about a specific device is in that file.</p>
<h2 id="svf-files">SVF Files</h2>
<p>Most JTAG adapter tool chains support a file format called SVF (Serial Vector Format). These are plain text files that describe
what data or instructions to write to the JTAG connection. It has no knowledge about the JTAG chain of devices or any of
there properties. We can just specify what data/instructions to shift in and what results we expect to be shifted out.</p>
<h2 id="designing-a-simple-test">Designing a simple test</h2>
<p>Okay so putting it all together. Lets say we want to test two neighboring interconnects for a bridging fault.</p>
<p>On my example PCB two neighboring interconnects are connected as follows:</p>
<ol>
<li>CHIP 1 <strong>IO56</strong> -  CHIP 2 <strong>IO49</strong></li>
<li>CHIP 1 <strong>IO55</strong> -  CHIP 2 <strong>IO50</strong></li>
</ol>
<p>So if we set <strong>IO56</strong> of the first chip to a logic 1 and <strong>IO55</strong> to logic 0, we would expect to receive a logic 1 on <strong>IO49</strong>
and a logic 0 at <strong>IO50</strong> on the second chip. If we receive a logic 1 at <strong>IO50</strong> that means that there is a bridging fault between
the interconnects.</p>
<p>To write a test for this we need to write an SVF file that we can run with the JTAG adapter tool chain. It needs to complete the
following steps:</p>
<ol>
<li>Set first chip into <strong>SAMPLE/PRELOAD</strong> mode. (Shift in Instructions)</li>
<li>Load Test pattern into first chip (Shift in Data)</li>
<li>Set first chip to <strong>EXTEST</strong> and second chip to <strong>SAMPLE/PRELOAD</strong> mode (Shift in Instructions)</li>
<li>Shift in dummy data to receive the data sampled from chip 2 and compare against the expected result (Shift in Data)</li>
</ol>
<p>The following SVF files does exactly this:</p>
<pre tabindex="0"><code class="language-svf" data-lang="svf">TRST OFF;
ENDIR IDLE;
ENDDR IDLE;
STATE RESET;
STATE IDLE;
FREQUENCY 10000000 HZ;
SIR 20 TDI (01405);
SDR 480 TDI (000000000000000000000000000000000000000000800000000000000
	000000000000000000000000000000000000000000000000000000000000000);
SIR 20 TDI (03c05);
SDR 480 TDI (0) TDO (000000000000000000000000000000000000000000000000
	00000000000000000000000000000000000000000000000100000000000000000
	0000000) MASK (00000000000000000000000000000000000000000000000000
	00000000000000000000000000000000000000000000012000000000000000000
	00000);
</code></pre><p>Up until the first line starting with <em>SIR</em> all we are doing is making sure the boundary-scan circuit is in a known state and setting the
speed at which we want to operate.</p>
<p><strong>SIR</strong> means we want to write instruction data. We need to specify the length and since we have to chips with both 10 bit instruction registers
we are writing 20 bits of data. The data we want to write is specified behind the <em>TDI</em> statement as a hex string surrounded by parenthesis.</p>
<p><strong>SDR</strong> works the same as <em>SIR</em> but instead of instruction data we are just writing data. In this case we are writing 480 bits, since
both chips have a boundary-scan register length of 240 bits. If we want to compare the shifted out data against the expected data
we have to write the expected result as a hex string behind the <em>TDO</em> statement and we can even mask the result so that we only look
at the bits we are interested in.</p>
<p>How do we know what data to write and what data to expect? Well for that we have to look at the BSDL files of the devices in our
JTAG chain and figure out which pin is mapped to which bit in the data. Of course writing a SVF by hand is very tedious, so instead
I created some <a href="https://github.com/ju6ge/jtag_testing">python scripts</a> to help me with the task. Feel free to use them for your
own projects.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Using Boundary-scan for PCB testing is very nice when trying to automatically test PCBs. Sadly there is little to no open source
software which makes it easy to design tests for your own layouts. Which means that you still have to do a lot of information gathering
if you want to use this technology. But once the tests are implemented testing a PCB becomes a very easy and fast.</p>
<p>I hope this blog post gave you an idea of what you need to do, to get up and running with boundary-scan testing. If you have any feedback
feel free to contact me.</p>
<h3 id="further-reading-material">Further Reading Material</h3>
<ul>
<li><a href="http://www.ti.com/lit/an/ssya002c/ssya002c.pdf">Texas Instruments Testabilty Primer</a></li>
<li><a href="https://pdfs.semanticscholar.org/9acb/ea9b3ddd1a80a01434d32912821837bd9af3.pdf">Paper on Interconnect Testing</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html"><![CDATA[Introduction to Hardware Peripherals]]></title>
    <link href="https://www.felixrichter.tech/posts/hardwareperipherals/"/>
    <id>https://www.felixrichter.tech/posts/hardwareperipherals/</id>
    <author>
      <name>Felix Richter</name>
    </author>
	<published>2019-12-27T00:00:00+00:00</published>
	<updated>2019-12-27T00:00:00+00:00</updated>
	<content type="html"><![CDATA[<p>Lately I have been doing programming for embedded systems such as the
esp32 and esp8266, and additionally I did a course on embedded systems for
my masters degree. This introduced me to the wonderful world of programming
close to the hardware level, and inspired me to write this post about
hardware peripherals.</p>
<h1 id="what-are-hardware-peripherals">What are Hardware Peripherals?</h1>
<p>Hardware Peripherals are specialized pieces of silicon that are built into
a processor. They are used to perform a diverse set of task. This includes
controlling the processors clock speed, power management and communication
with other devices. They are responsible for configuring the device operation
and during operation are used to perform tasks in parallel with the main
cores.</p>
<h4 id="so-what-can-these-peripherals-do">So what can these peripherals do?</h4>
<p>Anyone who has ever looked into the data sheet of a microprocessor will know
that these data sheets are long. The data sheet for the ARM cortex m7 CPU for
example is about 2000 pages long. Which is to say that there are a lot of
peripherals that can do a variety of things, for example:</p>
<ul>
<li><strong>Analog Digital Converters (ADC)</strong> used for measuring analog signals</li>
<li><strong>Direct Memory Access Controllers (DMA)</strong> used for copying data from sensor to memory or the other way</li>
<li><strong>GPIO Interfaces</strong> used for pin management</li>
<li><strong>I2C and SPI Interfaces</strong> used for communicating with sensor devices</li>
<li><strong>PMC</strong> the power management controller</li>
<li>Other Memory interfaces such as PCI or EBI</li>
</ul>
<h1 id="using-peripherals">Using Peripherals</h1>
<p>In order for us to use a peripheral, we have to complete a few steps:</p>
<ol>
<li>
<p>Setup peripheral mode</p>
</li>
<li>
<p>Start peripheral task</p>
</li>
<li>
<p>Wait for peripheral to finish</p>
</li>
</ol>
<p>All of this is done via memory mapped registers, which is to say that
within the memory range of the processor there are dedicated areas of memory
that do not map to a memory controller like an SDRAM, but are mapped to
registers belonging to the peripherals. The peripherals use these registers
as configuration values that change how the peripheral is working or if it
is running, and some of the registers are not meant to be written to but
instead are used to communicate the status of the peripheral back to the CPU.</p>
<p>All of this is described in the data sheet of the processor you are using. Every
peripheral has a section describing what it can do, and what parameters can
be changed via the memory mapped registers, as well as how the peripheral
can be started, stopped and how to know when it is finished.</p>
<p>Since all of this is highly dependent on the platform you are using, it is
hard to give you a clear cut way to use any peripheral. You will always have
to refer back to the data sheet and look how to use the peripheral for your
platform. But in order for you to get an idea on how to do this, let us look
at an example.</p>
<h2 id="example">Example</h2>
<p>Every example is specific to the specific device we are using. For
these examples we are going to look at the simple case of toggling
a GPIO pin. The chip we are using is an embedded cortex m7 cpu,
from atmel. It belongs to the atsame70 family of cpu&rsquo;s.
<a href="http://ww1.microchip.com/downloads/en/DeviceDoc/SAM-E70-S70-V70-V71-Family-Data-Sheet-DS60001527D.pdf">Datasheet</a></p>
<p>So all we want to do is let a led blink. To do this we will have to toggle
the status of a pin, and all pins are managed by the GPIO peripheral. In the
data sheet of this particular chip this peripheral is just called PIO. To be
able to do this we first have to tell the PIO peripheral that it should take
control of the pin and then tell it to configure the pin to be used as an
output. After that we can change the pin state.</p>
<p>If you already looked into the data sheet you might have noticed so that there
are multiple PIO peripherals and how the pins are mapped depends on the rest
of the system. For the system that i am programming a led is connected
to pin <strong>19</strong> on PIO <strong>C</strong>. So this is the pin I will be using in this example.</p>
<p>To achive an accurate timeout between turning the led on and off, we are
going to use the real time timer peripheral on our device. It is in essence
a configurable counter attached to a clock signal.</p>
<h3 id="let-us-do-this-in-c">Let us do this in C</h3>
<p>This example uses the C library provided by atmel which provides the correct
memory addresses of the peripherals and exposes them to us as definitions and
structures. By just using these we are automatically writing to the correct
addresses.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>	<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;atsame70.h&#34; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">timeout_ms</span>(<span style="color:#66d9ef">int</span> ms) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// restart timer and set prescaler to count every 32 clock cycles 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// this corresponds to a 1ms clock cycle since the clock frequency is 32 kHz 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		RTT<span style="color:#f92672">-&gt;</span>RTT_MR <span style="color:#f92672">=</span> RTT_MR_RTPRES(<span style="color:#ae81ff">0x20</span>) <span style="color:#f92672">|</span> RTT_MR_RTTRST; 
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> ( (RTT<span style="color:#f92672">-&gt;</span>RTT_VR <span style="color:#f92672">|</span> RTT_VR_CRTV_Msk) <span style="color:#f92672">&lt;</span> ms) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//wait for counter to have counted to desired timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">blink_led</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//give control of the pin to the pio -&gt; basically the running code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		ATSAME70_BASE_PIOC<span style="color:#f92672">-&gt;</span>PIO_PER <span style="color:#f92672">=</span> PIO_PC19; 
</span></span><span style="display:flex;"><span>		ATSAME70_BASE_PIOC<span style="color:#f92672">-&gt;</span>PIO_OER <span style="color:#f92672">=</span> PIO_PC19;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span>(true) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//turn led on 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ATSAME70_BASE_PIOC<span style="color:#f92672">-&gt;</span>PIO_SODR <span style="color:#f92672">=</span> PIO_PC19;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			timeout_ms(<span style="color:#ae81ff">500</span>); 
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//turn led off 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ATSAME70_BASE_PIOC<span style="color:#f92672">-&gt;</span>PIO_CODR <span style="color:#f92672">=</span> PIO_PC19; 
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			timeout_ms(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="timeouts">Timeouts</h4>
<p>Since the device can vary it&rsquo;s clock speed it is not desirable to implement a
delay with just waiting a specified amount of clock cycles. Instead we
are going to use the atsame70 <em>Real Time Timer</em> (RTT).</p>
<p>How to configure the RTT correctly can be read in the functional description in
the data sheet. In short we have to configure the clock source since there are
two at different speeds. Scale how many clock cycles trigger the counter and
reset the peripheral for the new setting to take affect.</p>
<p>To do this we have to write to a memory mapped register:</p>
<figure><img src="/hardware_peripherals/rtt_reg.png"/>
</figure>

<p>In the figure we can see all the registers that are connected to the RTT. All
the values we need to configure are in the RTT_MR register. It is basically just
a 32 bit value. But every bit has a meaning. The first 16 bits represent the 16
bit prescaler value, and there is also a bit to enable the peripheral and one to
the reset it. Selecting the clock source is also done with one bit.</p>
<p>So what do we need to wait for a certain amount of ms:</p>
<ol>
<li>
<p>Select the 32kHz clock src by setting the <strong>RTC1HZ</strong> bit in <strong>RTT_MR</strong> to <strong>0</strong></p>
</li>
<li>
<p>Setting the <strong>RTPRES</strong> 16 bit value to <strong>32</strong> in order for the counter to increase ever 32 clock cycles
which corresponds to increase the counter value evey 1ms</p>
</li>
<li>
<p>Set the <strong>RTTDIS</strong> bit to <strong>0</strong> to not disable the rtt</p>
</li>
<li>
<p>Trigger the RTT reset by setting <strong>RTTRST</strong> bit to <strong>1</strong></p>
</li>
</ol>
<p>All of these 4 steps can be done with one write to the <strong>RTT_MR</strong> register.</p>
<p>Afterwards the timer is running and we can read the value in <strong>RTT_VR</strong> to see how
much time has passed.</p>
<h4 id="controlling-the-led">Controlling the LED</h4>
<p>The PIO peripheral that manages the pins of the device is a lot more complex than the RTT peripheral. Which
means it has many more registers. Using these we can do fancy things like giving other peripherals such as
the SPI peripheral control over the pins it needs to communicate.</p>
<p>But we are just interested in simply controlling a pin ourselfs. For this we need 4 different registers:</p>
<ol>
<li>
<p><strong>PIO_PER</strong> peripheral enable register</p>
</li>
<li>
<p><strong>PIO_OER</strong> peripheral output enable register</p>
</li>
<li>
<p><strong>PIO_SODR</strong> set output data register</p>
</li>
<li>
<p><strong>PIO_CODR</strong> clear output data register</p>
</li>
</ol>
<p>They all have the same structure so i am just going to show you one of them:</p>
<figure><img src="/hardware_peripherals/pio_reg.png"/>
</figure>

<p>Basically for every pin controlled by the PIO there is a bit. So one PIO gives us control over 32 pins.
To control a pin we have to do the following steps:</p>
<ol>
<li>
<p>set <strong>PIO_PER</strong> pin bit to <em>1</em> to enable control of the PIO over the pin</p>
</li>
<li>
<p>set <strong>PIO_OER</strong> pin bit to <em>1</em> to set the pin into output mode</p>
</li>
</ol>
<p>Now setting the <strong>PIO_SODR</strong> pin bit to <em>1</em> to pull the pin high and setting the <strong>PIO_CODR</strong> pin bit to <em>1</em> pulls the pin low again.</p>
<h3 id="how-does-all-of-this-look-in-rust">How does all of this look in Rust</h3>
<p>For rust there is no official library from atmel, but there is a project
called svd2rust that allows us to auto-generate a library that we can use
to address the correct peripheral registers. All we need is the svd file of
the processor we are using, this is an xml file describing all the peripherals
and their register values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>	<span style="color:#66d9ef">use</span> atsame70q21::{Peripherals}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">timeout_ms</span>(peripherals : <span style="color:#66d9ef">&amp;</span> <span style="color:#a6e22e">Peripherals</span>, <span style="color:#66d9ef">u32</span> ms) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> rtt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>peripherals.RTT;
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// restart timer and set prescaler to count every 32 clock cycles 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// this corresponds to a 1ms clock cycle since the clock frequency is 32 kHz 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		rtt.rtt_mr.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsafe</span> {w.rtpres().bits(<span style="color:#ae81ff">0x20</span>);}
</span></span><span style="display:flex;"><span>			w.rttdis().clearbit();
</span></span><span style="display:flex;"><span>			w.rttrst().set_bit()
</span></span><span style="display:flex;"><span>		});
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> rtt.rtt_vr.read().crtv().bits() <span style="color:#f92672">&lt;</span> ms {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// wait for counter to have counted to desired timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">blink_led</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> peripherals <span style="color:#f92672">=</span> Peripherals::take().unwrap();
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> pioc <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>peripherals.PIOC;
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//give control of the pin to the pio -&gt; basically the running code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		pioc.pio_per.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> w.p19().set_bit() );
</span></span><span style="display:flex;"><span>		pioc.pio_oer.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> w.p19().set_bit() );
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">loop</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//turn led on 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pioc.pio_sodr.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> w.p19().set_bit() );
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			timeout_ms(<span style="color:#f92672">&amp;</span>peripherals, <span style="color:#ae81ff">500</span>); 
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//turn led off 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			pioc.pio_codr.write( <span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> w.p19().set_bit() );
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			timeout_ms(<span style="color:#f92672">&amp;</span>peripherals, <span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>The logic of the rust code is exactly the same as the C example, and since all of the actual functionality we are using
is provided by the hardware and not by the language specifics the code looks mostly the same.</p>
<p>I hope you liked this little excursion into bare metal programming, i am sure i will return with more blog post regarding
similar topics while i keep experimenting more with rust on bare metal systems.</p>
]]></content>
  </entry>
</feed>
